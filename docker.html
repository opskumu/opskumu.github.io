<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-09-23 Mon 20:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Docker 学习笔记</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Kumu" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/org.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
<script>var hlf=function(){Array.prototype.forEach.call(document.querySelectorAll("pre.src"),function(t){var e;e=t.getAttribute("class").toLowerCase(),e=e.replace(/src-(\w+)/,"src-$1 $1"),console.log(e),t.setAttribute("class",e),hljs.highlightBlock(t)})};addEventListener("DOMContentLoaded",hlf);</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/googlecode.min.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Docker 学习笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0819be8">1. Docker 简介</a>
<ul>
<li><a href="#orgef21b94">1.1. Docker 守护进程</a></li>
<li><a href="#org82cd0c2">1.2. Docker 客户端</a></li>
<li><a href="#orga7e9a25">1.3. Docker 内部</a>
<ul>
<li><a href="#org025e7ec">1.3.1. Docker 镜像</a></li>
<li><a href="#orgad7bcbe">1.3.2. Docker 仓库</a></li>
<li><a href="#orgb706e51">1.3.3. Docker 容器</a></li>
</ul>
</li>
<li><a href="#org0002ad1">1.4. libcontainer</a></li>
<li><a href="#orgf182677">1.5. 命名空间「Namespaces」</a>
<ul>
<li><a href="#orgd2ca01b">1.5.1. pid namespace</a></li>
<li><a href="#org248582e">1.5.2. mnt namespace</a></li>
<li><a href="#orgb9dbe32">1.5.3. net namespace</a></li>
<li><a href="#orga334507">1.5.4. uts namespace</a></li>
<li><a href="#orgcb787a9">1.5.5. ipc namespace</a></li>
<li><a href="#org8429f37">1.5.6. user namespace</a></li>
<li><a href="#orgb9c21af">1.5.7. Reference</a></li>
</ul>
</li>
<li><a href="#org30f76d7">1.6. 资源配额「cgroups」</a></li>
</ul>
</li>
<li><a href="#orgaa2eb4f">2. Docker 安装</a></li>
<li><a href="#org1289765">3. Docker 基础用法</a>
<ul>
<li><a href="#orgef9b7f1">3.1. Search images</a></li>
<li><a href="#org6c5188e">3.2. Pull images</a></li>
<li><a href="#orgc58a80a">3.3. Running an interactive shell</a></li>
<li><a href="#org6831777">3.4. 相关快捷键</a></li>
</ul>
</li>
<li><a href="#orgfa05598">4. Docker 命令帮助</a>
<ul>
<li><a href="#orga2f20f3">4.1. docker help</a>
<ul>
<li><a href="#org21f5b37">4.1.1. docker command</a></li>
<li><a href="#orgcd2fa4d">4.1.2. docker option</a></li>
</ul>
</li>
<li><a href="#orgdb29e12">4.2. docker search</a></li>
<li><a href="#org40aabbf">4.3. docker info</a></li>
<li><a href="#org0a5eea3">4.4. docker pull &amp;&amp; docker push</a></li>
<li><a href="#orgffe58ef">4.5. docker images</a></li>
<li><a href="#orgb3d503d">4.6. docker rmi</a></li>
<li><a href="#orgc62e3de">4.7. docker run</a></li>
<li><a href="#org343724f">4.8. docker start|stop|kill&#x2026; &#x2026;</a></li>
<li><a href="#orgaf9827b">4.9. Docker 1.3 新增特性和命令</a>
<ul>
<li><a href="#orga4d3a9e">4.9.1. Digital Signature Verification</a></li>
<li><a href="#org27efdbf">4.9.2. Inject new processes with <code>docker exec</code></a></li>
<li><a href="#orgdc74346">4.9.3. Tune container lifecycles with <code>docker create</code></a></li>
<li><a href="#orga6937a4">4.9.4. Security Options</a></li>
</ul>
</li>
<li><a href="#orgd607919">4.10. Docker 1.5 新特性</a></li>
</ul>
</li>
<li><a href="#org32f6d12">5. Docker 端口映射</a>
<ul>
<li><a href="#org565fa36">5.1. 自动映射端口</a></li>
<li><a href="#org11dc726">5.2. 绑定端口到指定接口</a>
<ul>
<li><a href="#org4fa1792">5.2.1. 绑定 TCP 端口</a></li>
<li><a href="#orga893843">5.2.2. 绑定 UDP 端口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge9d9aab">6. Docker 网络配置</a>
<ul>
<li><a href="#org52d349b">6.1. Docker 四种网络模式</a>
<ul>
<li><a href="#org2e9f13e">6.1.1. host 模式</a></li>
<li><a href="#org9ecc43d">6.1.2. container 模式</a></li>
<li><a href="#org826eb6c">6.1.3. none模式</a></li>
<li><a href="#orgc56048c">6.1.4. bridge模式</a></li>
</ul>
</li>
<li><a href="#org13430fd">6.2. 列出当前主机网桥</a></li>
<li><a href="#orgc3e0d67">6.3. 查看当前 docker0 ip</a></li>
<li><a href="#org4cb982a">6.4. 运行一个容器</a>
<ul>
<li><a href="#orgf728a28">6.4.1. 使用特定范围的 IP</a></li>
</ul>
</li>
<li><a href="#org5e73d00">6.5. 不同主机间容器通信</a>
<ul>
<li><a href="#org2944faa">6.5.1. 安装相应依赖软件</a></li>
<li><a href="#org3607e36">6.5.2. 桥接网络</a></li>
<li><a href="#org8933318">6.5.3. pipework</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgee4494c">7. Dockerfile</a>
<ul>
<li><a href="#orgd29a41f">7.1. FROM</a></li>
<li><a href="#org805c39f">7.2. MAINTAINER</a></li>
<li><a href="#org67c8482">7.3. CMD</a></li>
<li><a href="#orgfeae381">7.4. EXPOSE</a></li>
<li><a href="#orga046680">7.5. ENV</a></li>
<li><a href="#org83c10e3">7.6. ADD</a></li>
<li><a href="#orgfb0ad1d">7.7. COPY</a></li>
<li><a href="#org83f6e48">7.8. ENTRYPOINT</a>
<ul>
<li><a href="#orgd26c057">7.8.1. Exec form ENTRYPOINT 例子</a></li>
<li><a href="#org43d035c">7.8.2. Shell form ENTRYPOINT 例子</a></li>
</ul>
</li>
<li><a href="#orga69ada7">7.9. VOLUME</a></li>
<li><a href="#org531c72a">7.10. USER</a></li>
<li><a href="#org2772376">7.11. WORKDIR</a></li>
<li><a href="#org6b52598">7.12. ONBUILD</a></li>
<li><a href="#org9bb66f7">7.13. Dockerfile Examples</a></li>
<li><a href="#org706144e">7.14. docker build</a></li>
<li><a href="#org081ecf9">7.15. dockerfile 最佳实践</a>
<ul>
<li><a href="#org037ee8c">7.15.1. Dockerfile 指令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3c300b8">8. 容器数据管理</a>
<ul>
<li><a href="#orgf9281c5">8.1. 数据卷</a>
<ul>
<li><a href="#orgd85495e">8.1.1. 添加一个数据卷</a></li>
<li><a href="#orge0722ca">8.1.2. 挂载宿主机目录为一个数据卷</a></li>
</ul>
</li>
<li><a href="#orgd98ca35">8.2. 创建和挂载一个数据卷容器</a></li>
<li><a href="#org2e9f1a3">8.3. 备份、恢复或迁移数据卷</a>
<ul>
<li><a href="#org31ebf9b">8.3.1. 备份</a></li>
<li><a href="#orgad688cb">8.3.2. 恢复</a></li>
</ul>
</li>
<li><a href="#org1b8ab81">8.4. 删除 Volumes</a></li>
</ul>
</li>
<li><a href="#org0c3fe77">9. 链接容器</a>
<ul>
<li><a href="#org1fa99a3">9.1. 容器命名</a></li>
<li><a href="#orgb2afa10">9.2. 链接容器</a>
<ul>
<li><a href="#org01ed06d">9.2.1. 环境变量</a></li>
<li><a href="#org7603c1e">9.2.2. 更新 <code>/etc/hosts</code> 文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7ffd7fe">10. 构建私有库</a>
<ul>
<li><a href="#org032b36d">10.1. 快速构建</a></li>
<li><a href="#orgba8a8d0">10.2. 不使用容器构建 registry</a>
<ul>
<li><a href="#orgee1e5d0">10.2.1. 安装必要的软件</a></li>
<li><a href="#org5f06dad">10.2.2. 配置 docker-registry</a></li>
<li><a href="#org13bf186">10.2.3. 运行</a></li>
<li><a href="#orgdf29639">10.2.4. 高级启动方式 「不推荐」</a></li>
</ul>
</li>
<li><a href="#org08ca606">10.3. 提交指定容器到私有库</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0819be8" class="outline-2">
<h2 id="org0819be8"><span class="section-number-2">1</span> Docker 简介</h2>
<div class="outline-text-2" id="text-1">
<p>
Docker 两个主要部件：
</p>

<ul class="org-ul">
<li>Docker: 开源的容器虚拟化平台</li>
<li>Docker Hub: 用于分享、管理 Docker 容器的 Docker SaaS 平台 &#x2013; <a href="https://registry.hub.docker.com/search?q=library">Docker Hub</a></li>
</ul>

<p>
Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。
</p>


<div class="figure">
<p><img src="./images/docker_arch.png" alt="docker_arch.png" />
</p>
</div>
</div>

<div id="outline-container-orgef21b94" class="outline-3">
<h3 id="orgef21b94"><span class="section-number-3">1.1</span> Docker 守护进程</h3>
<div class="outline-text-3" id="text-1-1">
<p>
如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。
</p>
</div>
</div>

<div id="outline-container-org82cd0c2" class="outline-3">
<h3 id="org82cd0c2"><span class="section-number-3">1.2</span> Docker 客户端</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。
</p>
</div>
</div>

<div id="outline-container-orga7e9a25" class="outline-3">
<h3 id="orga7e9a25"><span class="section-number-3">1.3</span> Docker 内部</h3>
<div class="outline-text-3" id="text-1-3">
<p>
要理解 Docker 内部构建，需要理解以下三种部件：
</p>

<ul class="org-ul">
<li>Docker 镜像 - Docker images</li>
<li>Docker 仓库 - Docker registeries</li>
<li>Docker 容器 - Docker containers</li>
</ul>
</div>

<div id="outline-container-org025e7ec" class="outline-4">
<h4 id="org025e7ec"><span class="section-number-4">1.3.1</span> Docker 镜像</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。
</p>
</div>
</div>

<div id="outline-container-orgad7bcbe" class="outline-4">
<h4 id="orgad7bcbe"><span class="section-number-4">1.3.2</span> Docker 仓库</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。
</p>
</div>
</div>

<div id="outline-container-orgb706e51" class="outline-4">
<h4 id="orgb706e51"><span class="section-number-4">1.3.3</span> Docker 容器</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。
</p>
</div>
</div>
</div>

<div id="outline-container-org0002ad1" class="outline-3">
<h3 id="org0002ad1"><span class="section-number-3">1.4</span> libcontainer</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Docker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux
系统的交互图如下：
</p>


<div class="figure">
<p><img src="./images/libcontainer-linux.png" alt="libcontainer-linux.png" />
</p>
</div>

<ul class="org-ul">
<li>图片来源: <a href="http://blog.docker.com/2014/03/docker-0-9-introducing-execution-drivers-and-libcontainer/">Docker 0.9: introducing execution drivers and libcontainer</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf182677" class="outline-3">
<h3 id="orgf182677"><span class="section-number-3">1.5</span> 命名空间「Namespaces」</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgd2ca01b" class="outline-4">
<h4 id="orgd2ca01b"><span class="section-number-4">1.5.1</span> pid namespace</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:
</p>

<ul class="org-ul">
<li>每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)</li>
<li>每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程</li>
<li>因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程</li>
<li>因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid</li>
</ul>

<p>
参考文档：<a href="https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/">Introduction to Linux namespaces &#x2013; Part 3: PID</a>
</p>
</div>
</div>

<div id="outline-container-org248582e" class="outline-4">
<h4 id="org248582e"><span class="section-number-4">1.5.2</span> mnt namespace</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。
</p>
</div>
</div>

<div id="outline-container-orgb9dbe32" class="outline-4">
<h4 id="orgb9dbe32"><span class="section-number-4">1.5.3</span> net namespace</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge
连接在一起。
</p>

<p>
参考文档：<a href="https://blog.jtlebi.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/">Introductionto Linux namespaces &#x2013; Part 5: NET</a>
</p>
</div>
</div>

<div id="outline-container-orga334507" class="outline-4">
<h4 id="orga334507"><span class="section-number-4">1.5.4</span> uts namespace</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
UTS ("UNIX Time-sharing System") namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。
</p>

<p>
参考文档：<a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">Introductionto Linux namespaces &#x2013; Part 1: UTS</a>
</p>
</div>
</div>

<div id="outline-container-orgcb787a9" class="outline-4">
<h4 id="orgcb787a9"><span class="section-number-4">1.5.5</span> ipc namespace</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace
中的进程间交互，因此需要在 IPC 资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。
</p>

<p>
参考文档：<a href="https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/">Introduction to Linux namespaces &#x2013; Part 2: IPC</a>
</p>
</div>
</div>

<div id="outline-container-org8429f37" class="outline-4">
<h4 id="org8429f37"><span class="section-number-4">1.5.6</span> user namespace</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。
</p>

<p>
有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。
</p>
</div>
</div>

<div id="outline-container-orgb9c21af" class="outline-4">
<h4 id="orgb9c21af"><span class="section-number-4">1.5.7</span> Reference</h4>
<div class="outline-text-4" id="text-1-5-7">
<ul class="org-ul">
<li><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/">Docker Getting Start: Related Knowledge</a></li>
<li><a href="https://ruby-china.org/topics/22004">Docker 介绍以及其相关术语、底层原理和技术</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org30f76d7" class="outline-3">
<h3 id="org30f76d7"><span class="section-number-3">1.6</span> 资源配额「cgroups」</h3>
<div class="outline-text-3" id="text-1-6">
<p>
cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usage_in_bytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。
</p>

<ul class="org-ul">
<li>memory
<ul class="org-ul">
<li>内存相关的限制</li>
</ul></li>
<li>cpu
<ul class="org-ul">
<li>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares，即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值</li>
</ul></li>
<li>blkio
<ul class="org-ul">
<li>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO</li>
</ul></li>
<li>devices
<ul class="org-ul">
<li>设备权限限制</li>
</ul></li>
</ul>

<p>
参考文档：<a href="http://tiewei.github.io/devops/howto-use-cgroup/">how to use cgroup</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgaa2eb4f" class="outline-2">
<h2 id="orgaa2eb4f"><span class="section-number-2">2</span> Docker 安装</h2>
<div class="outline-text-2" id="text-2">
<p>
docker 的相关安装方法这里不作介绍，具体安装参考 <a href="https://docs.docker.com/installation/">官档</a>
</p>

<p>
获取当前 docker 版本
</p>

<pre class="example">
$ sudo docker version
Client version: 1.3.2
Client API version: 1.15
Go version (client): go1.3.3
Git commit (client): 39fa2fa/1.3.2
OS/Arch (client): linux/amd64
Server version: 1.3.2
Server API version: 1.15
Go version (server): go1.3.3
Git commit (server): 39fa2fa/1.3.2
</pre>
</div>
</div>

<div id="outline-container-org1289765" class="outline-2">
<h2 id="org1289765"><span class="section-number-2">3</span> Docker 基础用法</h2>
<div class="outline-text-2" id="text-3">
<p>
<a href="https://registry.hub.docker.com/">Docker HUB</a> ：Docker镜像首页，包括官方镜像和其它公开镜像
</p>

<p>
因为国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用 <a href="http://daocloud.com/">Daocloud</a> 镜像加速。
</p>
</div>

<div id="outline-container-orgef9b7f1" class="outline-3">
<h3 id="orgef9b7f1"><span class="section-number-3">3.1</span> Search images</h3>
<div class="outline-text-3" id="text-3-1">
<pre class="example">
$ sudo docker search ubuntu
</pre>
</div>
</div>

<div id="outline-container-org6c5188e" class="outline-3">
<h3 id="org6c5188e"><span class="section-number-3">3.2</span> Pull images</h3>
<div class="outline-text-3" id="text-3-2">
<pre class="example">
$ sudo docker pull ubuntu # 获取 ubuntu 官方镜像
$ sudo docker images # 查看当前镜像列表
</pre>
</div>
</div>

<div id="outline-container-orgc58a80a" class="outline-3">
<h3 id="orgc58a80a"><span class="section-number-3">3.3</span> Running an interactive shell</h3>
<div class="outline-text-3" id="text-3-3">
<pre class="example">
$ sudo docker run -i -t ubuntu:14.04 /bin/bash
</pre>

<ul class="org-ul">
<li>docker run - 运行一个容器</li>
<li>-t - 分配一个（伪）tty (link is external)</li>
<li>-i - 交互模式 (so we can interact with it)</li>
<li>ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04</li>
<li>/bin/bash - 运行命令 bash shell</li>
</ul>

<p>
<b>注:</b> ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]
</p>

<pre class="example">
$ sudo docker ps # 查看当前运行的容器, ps -a 列出当前系统所有的容器
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
6c9129e9df10        ubuntu:14.04        /bin/bash           6 minutes ago       Up 6 minutes                            cranky_babbage
</pre>
</div>
</div>

<div id="outline-container-org6831777" class="outline-3">
<h3 id="org6831777"><span class="section-number-3">3.4</span> 相关快捷键</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>退出： <code>Ctrl-D</code> or <code>exit</code></li>
<li>detach： <code>Ctrl-P + Ctrl-Q</code></li>
<li>attach: <code>docker attach CONTAINER-ID</code></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfa05598" class="outline-2">
<h2 id="orgfa05598"><span class="section-number-2">4</span> Docker 命令帮助</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orga2f20f3" class="outline-3">
<h3 id="orga2f20f3"><span class="section-number-3">4.1</span> docker help</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org21f5b37" class="outline-4">
<h4 id="org21f5b37"><span class="section-number-4">4.1.1</span> docker command</h4>
<div class="outline-text-4" id="text-4-1-1">
<pre class="example">
$ sudo docker   # docker 命令帮助

Commands:
    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像
    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像
    commit    Create a new image from a container's changes # 提交当前容器为新的镜像
    cp        Copy files/folders from the containers filesystem to the host path
              # 从容器中拷贝指定文件或者目录到宿主机中
    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器
    diff      Inspect changes on a container's filesystem   # 查看 docker 容器变化
    events    Get real time events from the server          # 从 docker 服务获取容器实时事件
    exec      Run a command in an existing container        # 在已存在的容器上运行命令
    export    Stream the contents of a container as a tar archive
              # 导出容器的内容流作为一个 tar 归档文件[对应 import ]
    history   Show the history of an image                  # 展示一个镜像形成历史
    images    List images                                   # 列出系统当前镜像
    import    Create a new filesystem image from the contents of a tarball
              # 从tar包中的内容创建一个新的文件系统映像[对应 export]
    info      Display system-wide information               # 显示系统相关信息
    inspect   Return low-level information on a container   # 查看容器详细信息
    kill      Kill a running container                      # kill 指定 docker 容器
    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]
    login     Register or Login to the docker registry server
              # 注册或者登陆一个 docker 源服务器
    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出
    logs      Fetch the logs of a container                 # 输出当前容器日志信息
    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT
              # 查看映射端口对应的容器内部源端口
    pause     Pause all processes within a container        # 暂停容器
    ps        List containers                               # 列出容器列表
    pull      Pull an image or a repository from the docker registry server
              # 从docker镜像源服务器拉取指定镜像或者库镜像
    push      Push an image or a repository to the docker registry server
              # 推送指定镜像或者库镜像至docker源服务器
    restart   Restart a running container                   # 重启运行的容器
    rm        Remove one or more containers                 # 移除一个或者多个容器
    rmi       Remove one or more images
              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]
    run       Run a command in a new container
              # 创建一个新的容器并运行一个命令
    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]
    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像
    start     Start a stopped containers                    # 启动容器
    stop      Stop a running containers                     # 停止容器
    tag       Tag an image into a repository                # 给源中镜像打标签
    top       Lookup the running processes of a container   # 查看容器中运行的进程信息
    unpause   Unpause a paused container                    # 取消暂停容器
    version   Show the docker version information           # 查看 docker 版本号
    wait      Block until a container stops, then print its exit code
              # 截取容器停止时的退出状态值
Run 'docker COMMAND --help' for more information on a command.
</pre>
</div>
</div>

<div id="outline-container-orgcd2fa4d" class="outline-4">
<h4 id="orgcd2fa4d"><span class="section-number-4">4.1.2</span> docker option</h4>
<div class="outline-text-4" id="text-4-1-2">
<pre class="example">
Usage of docker:
  --api-enable-cors=false                Enable CORS headers in the remote API                      # 远程 API 中开启 CORS 头
  -b, --bridge=""                        Attach containers to a pre-existing network bridge         # 桥接网络
                                           use 'none' to disable container networking
  --bip=""                               Use this CIDR notation address for the network bridge's IP, not compatible with -b
                                         # 和 -b 选项不兼容，具体没有测试过
  -d, --daemon=false                     Enable daemon mode                                         # daemon 模式
  -D, --debug=false                      Enable debug mode                                          # debug 模式
  --dns=[]                               Force docker to use specific DNS servers                   # 强制 docker 使用指定 dns 服务器
  --dns-search=[]                        Force Docker to use specific DNS search domains            # 强制 docker 使用指定 dns 搜索域
  -e, --exec-driver="native"             Force the docker runtime to use a specific exec driver     # 强制 docker 运行时使用指定执行驱动器
  --fixed-cidr=""                        IPv4 subnet for fixed IPs (ex: 10.20.0.0/16)
                                           this subnet must be nested in the bridge subnet (which is defined by -b or --bip)
  -G, --group="docker"                   Group to assign the unix socket specified by -H when running in daemon mode
                                           use '' (the empty string) to disable setting of a group
  -g, --graph="/var/lib/docker"          Path to use as the root of the docker runtime              # 容器运行的根目录路径
  -H, --host=[]                          The socket(s) to bind to in daemon mode                    # daemon 模式下 docker 指定绑定方式[tcp or 本地 socket]
                                           specified using one or more tcp://host:port, unix:///path/to/socket, fd://* or fd://socketfd.
  --icc=true                             Enable inter-container communication                       # 跨容器通信
  --insecure-registry=[]                 Enable insecure communication with specified registries (no certificate verification for HTTPS and enable HTTP fallback) (e.g., localhost:5000 or 10.20.0.0/16)
  --ip="0.0.0.0"                         Default IP address to use when binding container ports     # 指定监听地址，默认所有 ip
  --ip-forward=true                      Enable net.ipv4.ip_forward                                 # 开启转发
  --ip-masq=true                         Enable IP masquerading for bridge's IP range
  --iptables=true                        Enable Docker's addition of iptables rules                 # 添加对应 iptables 规则
  --mtu=0                                Set the containers network MTU                             # 设置网络 mtu
                                           if no value is provided: default to the default route MTU or 1500 if no default route is available
  -p, --pidfile="/var/run/docker.pid"    Path to use for daemon PID file                            # 指定 pid 文件位置
  --registry-mirror=[]                   Specify a preferred Docker registry mirror
  -s, --storage-driver=""                Force the docker runtime to use a specific storage driver  # 强制 docker 运行时使用指定存储驱动
  --selinux-enabled=false                Enable selinux support                                     # 开启 selinux 支持
  --storage-opt=[]                       Set storage driver options                                 # 设置存储驱动选项
  --tls=false                            Use TLS; implied by tls-verify flags                       # 开启 tls
  --tlscacert="/root/.docker/ca.pem"     Trust only remotes providing a certificate signed by the CA given here
  --tlscert="/root/.docker/cert.pem"     Path to TLS certificate file                               # tls 证书文件位置
  --tlskey="/root/.docker/key.pem"       Path to TLS key file                                       # tls key 文件位置
  --tlsverify=false                      Use TLS and verify the remote (daemon: verify client, client: verify daemon) # 使用 tls 并确认远程控制主机
  -v, --version=false                    Print version information and quit                         # 输出 docker 版本信息
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdb29e12" class="outline-3">
<h3 id="orgdb29e12"><span class="section-number-3">4.2</span> docker search</h3>
<div class="outline-text-3" id="text-4-2">
<pre class="example">
$ sudo docker search --help

Usage: docker search TERM

Search the Docker Hub for images     # 从 Docker Hub 搜索镜像

  --automated=false    Only show automated builds
  --no-trunc=false     Don't truncate output
  -s, --stars=0        Only displays with at least xxx stars
</pre>

<p>
示例：
</p>

<pre class="example">
$ sudo docker search -s 100 ubuntu
# 查找 star 数至少为 100 的镜像，找出只有官方镜像 start 数超过 100，默认不加 s 选项找出所有相关 ubuntu 镜像
NAME      DESCRIPTION                  STARS     OFFICIAL   AUTOMATED
ubuntu    Official Ubuntu base image   425       [OK]
</pre>
</div>
</div>

<div id="outline-container-org40aabbf" class="outline-3">
<h3 id="org40aabbf"><span class="section-number-3">4.3</span> docker info</h3>
<div class="outline-text-3" id="text-4-3">
<pre class="example">
$ sudo docker info
Containers: 1                       # 容器个数
Images: 22                          # 镜像个数
Storage Driver: devicemapper        # 存储驱动
 Pool Name: docker-8:17-3221225728-pool
 Pool Blocksize: 65.54 kB
 Data file: /data/docker/devicemapper/devicemapper/data
 Metadata file: /data/docker/devicemapper/devicemapper/metadata
 Data Space Used: 1.83 GB
 Data Space Total: 107.4 GB
 Metadata Space Used: 2.191 MB
 Metadata Space Total: 2.147 GB
 Library Version: 1.02.84-RHEL7 (2014-03-26)
Execution Driver: native-0.2        # 存储驱动
Kernel Version: 3.10.0-123.el7.x86_64
Operating System: CentOS Linux 7 (Core)
</pre>
</div>
</div>

<div id="outline-container-org0a5eea3" class="outline-3">
<h3 id="org0a5eea3"><span class="section-number-3">4.4</span> docker pull &amp;&amp; docker push</h3>
<div class="outline-text-3" id="text-4-4">
<pre class="example">
$ sudo docker pull --help           # pull 拉取镜像

Usage: docker pull [OPTIONS] NAME[:TAG]

Pull an image or a repository from the registry

  -a, --all-tags=false    Download all tagged images in the repository

$ sudo docker push                  # push 推送指定镜像

Usage: docker push NAME[:TAG]

Push an image or a repository to the registry
</pre>

<p>
示例：
</p>

<pre class="example">
$ sudo docker pull ubuntu           # 下载官方 ubuntu docker 镜像，默认下载所有 ubuntu 官方库镜像
$ sudo docker pull ubuntu:14.04     # 下载指定版本 ubuntu 官方镜像
</pre>

<pre class="example">
$ sudo docker push 192.168.0.100:5000/ubuntu
# 推送镜像库到私有源[可注册 docker 官方账户，推送到官方自有账户]
$ sudo docker push 192.168.0.100:5000/ubuntu:14.04
# 推送指定镜像到私有源
</pre>
</div>
</div>

<div id="outline-container-orgffe58ef" class="outline-3">
<h3 id="orgffe58ef"><span class="section-number-3">4.5</span> docker images</h3>
<div class="outline-text-3" id="text-4-5">
<p>
列出当前系统镜像
</p>

<pre class="example">
$ sudo docker images --help

Usage: docker images [OPTIONS] [NAME]

List images

  -a, --all=false      Show all images (by default filter out the intermediate image layers)
  # -a 显示当前系统的所有镜像，包括过渡层镜像，默认 docker images 显示最终镜像，不包括过渡层镜像
  -f, --filter=[]      Provide filter values (i.e. 'dangling=true')
  --no-trunc=false     Don't truncate output
  -q, --quiet=false    Only show numeric IDs
</pre>

<p>
示例：
</p>

<pre class="example">
$ sudo docker images            # 显示当前系统镜像，不包括过渡层镜像
$ sudo docker images -a         # 显示当前系统所有镜像，包括过渡层镜像
$ sudo docker images ubuntu     # 显示当前系统 docker ubuntu 库中的所有镜像
REPOSITORY                 TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                     12.04               ebe4be4dd427        4 weeks ago         210.6 MB
ubuntu                     14.04               e54ca5efa2e9        4 weeks ago         276.5 MB
ubuntu                     14.04-ssh           6334d3ac099a        7 weeks ago         383.2 MB
</pre>
</div>
</div>

<div id="outline-container-orgb3d503d" class="outline-3">
<h3 id="orgb3d503d"><span class="section-number-3">4.6</span> docker rmi</h3>
<div class="outline-text-3" id="text-4-6">
<p>
删除一个或者多个镜像
</p>

<pre class="example">
$ sudo docker rmi --help

Usage: docker rmi IMAGE [IMAGE...]

Remove one or more images

  -f, --force=false    Force removal of the image       # 强制移除镜像不管是否有容器使用该镜像
  --no-prune=false     Do not delete untagged parents   # 不要删除未标记的父镜像
</pre>
</div>
</div>

<div id="outline-container-orgc62e3de" class="outline-3">
<h3 id="orgc62e3de"><span class="section-number-3">4.7</span> docker run</h3>
<div class="outline-text-3" id="text-4-7">
<pre class="example">
$ sudo docker run --help

Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

Run a command in a new container

  -a, --attach=[]            Attach to stdin, stdout or stderr.
  -c, --cpu-shares=0         CPU shares (relative weight)                       # 设置 cpu 使用权重
  --cap-add=[]               Add Linux capabilities
  --cap-drop=[]              Drop Linux capabilities
  --cidfile=""               Write the container ID to the file                 # 把容器 id 写入到指定文件
  --cpuset=""                CPUs in which to allow execution (0-3, 0,1)        # cpu 绑定
  -d, --detach=false         Detached mode: Run container in the background, print new container id # 后台运行容器
  --device=[]                Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc)
  --dns=[]                   Set custom dns servers                             # 设置 dns
  --dns-search=[]            Set custom dns search domains                      # 设置 dns 域搜索
  -e, --env=[]               Set environment variables                          # 定义环境变量
  --entrypoint=""            Overwrite the default entrypoint of the image      # ？
  --env-file=[]              Read in a line delimited file of ENV variables     # 从指定文件读取变量值
  --expose=[]                Expose a port from the container without publishing it to your host    # 指定对外提供服务端口
  -h, --hostname=""          Container host name                                # 设置容器主机名
  -i, --interactive=false    Keep stdin open even if not attached               # 保持标准输出开启即使没有 attached
  --link=[]                  Add link to another container (name:alias)         # 添加链接到另外一个容器
  --lxc-conf=[]              (lxc exec-driver only) Add custom lxc options --lxc-conf="lxc.cgroup.cpuset.cpus = 0,1"
  -m, --memory=""            Memory limit (format: &lt;number&gt;&lt;optional unit&gt;, where unit = b, k, m or g) # 内存限制
  --name=""                  Assign a name to the container                     # 设置容器名
  --net="bridge"             Set the Network mode for the container             # 设置容器网络模式
                               'bridge': creates a new network stack for the container on the docker bridge
                               'none': no networking for this container
                               'container:&lt;name|id&gt;': reuses another container network stack
                               'host': use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.
  -P, --publish-all=false    Publish all exposed ports to the host interfaces   # 自动映射容器对外提供服务的端口
  -p, --publish=[]           Publish a container's port to the host             # 指定端口映射
                               format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort
                               (use 'docker port' to see the actual mapping)
  --privileged=false         Give extended privileges to this container         # 提供更多的权限给容器
  --restart=""               Restart policy to apply when a container exits (no, on-failure[:max-retry], always)
  --rm=false                 Automatically remove the container when it exits (incompatible with -d) # 如果容器退出自动移除和 -d 选项冲突
  --security-opt=[]          Security Options
  --sig-proxy=true           Proxify received signals to the process (even in non-tty mode). SIGCHLD is not proxied.
  -t, --tty=false            Allocate a pseudo-tty                              # 分配伪终端
  -u, --user=""              Username or UID                                    # 指定运行容器的用户 uid 或者用户名
  -v, --volume=[]            Bind mount a volume (e.g., from the host: -v /host:/container, from docker: -v /container)
                             # 挂载卷
  --volumes-from=[]          Mount volumes from the specified container(s)      # 从指定容器挂载卷
  -w, --workdir=""           Working directory inside the container             # 指定容器工作目录
</pre>

<p>
示例：
</p>

<pre class="example">
$ sudo docker images ubuntu
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              14.04               e54ca5efa2e9        4 weeks ago         276.5 MB
... ...
$ sudo docker run -t -i -c 100 -m 512MB -h test1 -d --name="docker_test1" ubuntu /bin/bash
# 创建一个 cpu 优先级为 100，内存限制 512MB，主机名为 test1，名为 docker_test1 后台运行 bash 的容器
a424ca613c9f2247cd3ede95adfbaf8d28400cbcb1d5f9b69a7b56f97b2b52e5
$ sudo docker ps
CONTAINER ID        IMAGE           COMMAND         CREATED             STATUS              PORTS       NAMES
a424ca613c9f        ubuntu:14.04    /bin/bash       6 seconds ago       Up 5 seconds                    docker_test1
$ sudo docker attach docker_test1
root@test1:/# pwd
/
root@test1:/# exit
exit
</pre>

<p>
<b>关于cpu优先级:</b>
</p>

<blockquote>
<p>
By default all groups have 1024 shares. A group with 100 shares will get a ~10% portion of the CPU time - <a href="https://wiki.archlinux.org/index.php/cgroups">archlinux cgroups</a>
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org343724f" class="outline-3">
<h3 id="org343724f"><span class="section-number-3">4.8</span> docker start|stop|kill&#x2026; &#x2026;</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>docker start CONTAINER [CONTAINER&#x2026;]
<ul class="org-ul">
<li># 运行一个或多个停止的容器</li>
</ul></li>
<li>docker stop CONTAINER [CONTAINER&#x2026;]
<ul class="org-ul">
<li># 停掉一个或多个运行的容器 <code>-t</code> 选项可指定超时时间</li>
</ul></li>
<li>docker kill [OPTIONS] CONTAINER [CONTAINER&#x2026;]
<ul class="org-ul">
<li># 默认 kill 发送 SIGKILL 信号 <code>-s</code> 可以指定发送 kill 信号类型</li>
</ul></li>
<li>docker restart [OPTIONS] CONTAINER [CONTAINER&#x2026;]
<ul class="org-ul">
<li># 重启一个或多个运行的容器 <code>-t</code> 选项可指定超时时间</li>
</ul></li>
<li>docker pause CONTAINER
<ul class="org-ul">
<li># 暂停一个容器，方便 commit</li>
</ul></li>
<li>docker unpause CONTAINER
<ul class="org-ul">
<li># 继续暂停的容器</li>
</ul></li>
<li>docker rm [OPTIONS] CONTAINER [CONTAINER&#x2026;]
<ul class="org-ul">
<li># 移除一个或多个容器</li>
<li>-f, &#x2013;force=false Force removal of running container</li>
<li>-l, &#x2013;link=false Remove the specified link and not the underlying container</li>
<li>-v, &#x2013;volumes=false Remove the volumes associated with the container</li>
</ul></li>
<li>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
<ul class="org-ul">
<li># 提交指定容器为镜像</li>
<li>-a, &#x2013;author="" Author (e.g., "John Hannibal Smith <a href="mailto:hannibal@a-team.com">hannibal@a-team.com</a>")</li>
<li>-m, &#x2013;message="" Commit message</li>
<li>-p, &#x2013;pause=true Pause container during commit
<ul class="org-ul">
<li># 默认 commit 是暂停状态</li>
</ul></li>
</ul></li>
<li>docker inspect CONTAINER|IMAGE [CONTAINER|IMAGE&#x2026;]
<ul class="org-ul">
<li># 查看容器或者镜像的详细信息</li>
</ul></li>
<li>docker logs CONTAINER
<ul class="org-ul">
<li># 输出指定容器日志信息</li>
<li>-f, &#x2013;follow=false Follow log output
<ul class="org-ul">
<li># 类似 tail -f</li>
</ul></li>
<li>-t, &#x2013;timestamps=false Show timestamps</li>
<li>&#x2013;tail="all" Output the specified number of lines at the end of logs
(defaults to all logs)</li>
</ul></li>
</ul>

<p>
参考文档：<a href="https://docs.docker.com/reference/run/">Docker Run Reference</a>
</p>
</div>
</div>

<div id="outline-container-orgaf9827b" class="outline-3">
<h3 id="orgaf9827b"><span class="section-number-3">4.9</span> Docker 1.3 新增特性和命令</h3>
<div class="outline-text-3" id="text-4-9">
</div>
<div id="outline-container-orga4d3a9e" class="outline-4">
<h4 id="orga4d3a9e"><span class="section-number-4">4.9.1</span> Digital Signature Verification</h4>
<div class="outline-text-4" id="text-4-9-1">
<p>
Docker 1.3 版本将使用数字签名自动验证所有官方库的来源和完整性，如果一个官方镜像被篡改或者被破坏，目前 Docker 只会对这种情况发出警告而并不阻止容器的运行。
</p>
</div>
</div>

<div id="outline-container-org27efdbf" class="outline-4">
<h4 id="org27efdbf"><span class="section-number-4">4.9.2</span> Inject new processes with <code>docker exec</code></h4>
<div class="outline-text-4" id="text-4-9-2">
<pre class="example">
docker exec --help

Usage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]

Run a command in an existing container

  -d, --detach=false         Detached mode: run command in the background
  -i, --interactive=false    Keep STDIN open even if not attached
  -t, --tty=false            Allocate a pseudo-TTY
</pre>

<p>
为了简化调试，可以使用 <code>docker exec</code> 命令通过 Docker API 和 CLI 在运行的容器上运行程序。
</p>

<pre class="example">
$ docker exec -it ubuntu_bash bash
</pre>

<p>
上例将在容器 ubuntu_bash 中创建一个新的 Bash 会话。
</p>
</div>
</div>

<div id="outline-container-orgdc74346" class="outline-4">
<h4 id="orgdc74346"><span class="section-number-4">4.9.3</span> Tune container lifecycles with <code>docker create</code></h4>
<div class="outline-text-4" id="text-4-9-3">
<p>
我们可以通过 <code>docker run &lt;image name&gt;</code> 命令创建一个容器并运行其中的程序，因为有很多用户要求创建容器的时候不启动容器，所以 <code>docker create</code> 应运而生了。
</p>

<pre class="example">
$ docker create -t -i fedora bash
6d8af538ec541dd581ebc2a24153a28329acb5268abe5ef868c1f1a261221752
</pre>

<p>
上例创建了一个可写的容器层 (并且打印出容器 ID)，但是并不运行它，可以使用以下命令运行该容器：
</p>

<pre class="example">
$ docker start -a -i 6d8af538ec5
bash-4.2#
</pre>
</div>
</div>

<div id="outline-container-orga6937a4" class="outline-4">
<h4 id="orga6937a4"><span class="section-number-4">4.9.4</span> Security Options</h4>
<div class="outline-text-4" id="text-4-9-4">
<p>
通过 <code>--security-opt</code> 选项，运行容器时用户可自定义 SELinux 和 AppArmor 卷标和配置。
</p>

<pre class="example">
$ docker run --security-opt label:type:svirt_apache -i -t centos \ bash
</pre>

<p>
上例只允许容器监听在 Apache 端口，这个选项的好处是用户不需要运行 docker 的时候指定 <code>--privileged</code> 选项，降低安全风险。
</p>

<p>
参考文档：<a href="http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/">Docker 1.3: signed images, process injection, security options, Mac shared directories</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgd607919" class="outline-3">
<h3 id="orgd607919"><span class="section-number-3">4.10</span> Docker 1.5 新特性</h3>
<div class="outline-text-3" id="text-4-10">
<p>
参考文档：<a href="http://dockerone.com/article/202">Docker 1.5 新特性</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org32f6d12" class="outline-2">
<h2 id="org32f6d12"><span class="section-number-2">5</span> Docker 端口映射</h2>
<div class="outline-text-2" id="text-5">
<pre class="example">
# Find IP address of container with ID &lt;container_id&gt; 通过容器 id 获取 ip
$ sudo docker inspect &lt;container_id&gt; | grep IPAddress | cut -d '"' -f 4
</pre>

<p>
无论如何，这些 ip 是基于本地系统的并且容器的端口非本地主机是访问不到的。此外，除了端口只能本地访问外，对于容器的另外一个问题是这些 ip 在容器每次启动的时候都会改变。
</p>

<p>
Docker 解决了容器的这两个问题，并且给容器内部服务的访问提供了一个简单而可靠的方法。Docker 通过端口绑定主机系统的接口，允许非本地客户端访问容器内部运行的服务。为了简便的使得容器间通信，Docker 提供了这种连接机制。
</p>
</div>

<div id="outline-container-org565fa36" class="outline-3">
<h3 id="org565fa36"><span class="section-number-3">5.1</span> 自动映射端口</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<code>-P</code> 使用时需要指定 <code>--expose</code> 选项，指定需要对外提供服务的端口
</p>

<pre class="example">
$ sudo docker run -t -P --expose 22 --name server  ubuntu:14.04
</pre>

<p>
使用 <code>docker run -P</code> 自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中 (49000..49900) 自动选择，你可以通过 <code>docker ps</code> 、 <code>docker inspect &lt;container_id&gt;</code> 或者 <code>docker port &lt;container_id&gt; &lt;port&gt;</code> 确定具体的绑定信息。
</p>
</div>
</div>

<div id="outline-container-org11dc726" class="outline-3">
<h3 id="org11dc726"><span class="section-number-3">5.2</span> 绑定端口到指定接口</h3>
<div class="outline-text-3" id="text-5-2">
<p>
基本语法
</p>

<pre class="example">
$ sudo docker run -p [([&lt;host_interface&gt;:[host_port]])|(&lt;host_port&gt;):]&lt;container_port&gt;[/udp] &lt;image&gt; &lt;cmd&gt;
</pre>

<p>
默认不指定绑定 ip 则监听所有网络接口。
</p>
</div>

<div id="outline-container-org4fa1792" class="outline-4">
<h4 id="org4fa1792"><span class="section-number-4">5.2.1</span> 绑定 TCP 端口</h4>
<div class="outline-text-4" id="text-5-2-1">
<pre class="example">
# Bind TCP port 8080 of the container to TCP port 80 on 127.0.0.1 of the host machine.
$ sudo docker run -p 127.0.0.1:80:8080 &lt;image&gt; &lt;cmd&gt;
# Bind TCP port 8080 of the container to a dynamically allocated TCP port on 127.0.0.1 of the host machine.
$ sudo docker run -p 127.0.0.1::8080 &lt;image&gt; &lt;cmd&gt;
# Bind TCP port 8080 of the container to TCP port 80 on all available interfaces of the host machine.
$ sudo docker run -p 80:8080 &lt;image&gt; &lt;cmd&gt;
# Bind TCP port 8080 of the container to a dynamically allocated TCP port on all available interfaces
$ sudo docker run -p 8080 &lt;image&gt; &lt;cmd&gt;
</pre>
</div>
</div>

<div id="outline-container-orga893843" class="outline-4">
<h4 id="orga893843"><span class="section-number-4">5.2.2</span> 绑定 UDP 端口</h4>
<div class="outline-text-4" id="text-5-2-2">
<pre class="example">
# Bind UDP port 5353 of the container to UDP port 53 on 127.0.0.1 of the host machine.
$ sudo docker run -p 127.0.0.1:53:5353/udp &lt;image&gt; &lt;cmd&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge9d9aab" class="outline-2">
<h2 id="orge9d9aab"><span class="section-number-2">6</span> Docker 网络配置</h2>
<div class="outline-text-2" id="text-6">

<div class="figure">
<p><img src="./images/docker_networking.png" alt="docker_networking.png" />
</p>
</div>

<p>
图: <a href="http://www.slideshare.net/janghoonsim/docker-container-and-lightweight-virtualization">Docker - container and lightweight virtualization</a>
</p>

<p>
Dokcer 通过使用 Linux 桥接提供容器之间的通信，docker0 桥接接口的目的就是方便 Docker 管理。当 Docker daemon 启动时需要做以下操作：
</p>

<ul class="org-ul">
<li>creates the docker0 bridge if not present
<ul class="org-ul">
<li># 如果 docker0 不存在则创建</li>
</ul></li>
<li>searches for an IP address range which doesn't overlap with an existing route
<ul class="org-ul">
<li># 搜索一个与当前路由不冲突的 ip 段</li>
</ul></li>
<li>picks an IP in the selected range
<ul class="org-ul">
<li># 在确定的范围中选择 ip</li>
</ul></li>
<li>assigns this IP to the docker0 bridge
<ul class="org-ul">
<li># 绑定 ip 到 docker0</li>
</ul></li>
</ul>
</div>

<div id="outline-container-org52d349b" class="outline-3">
<h3 id="org52d349b"><span class="section-number-3">6.1</span> Docker 四种网络模式</h3>
<div class="outline-text-3" id="text-6-1">
<p>
四种网络模式摘自<a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice">Docker网络详解及 pipework 源码解读与实践</a>
</p>

<p>
docker run 创建 Docker 容器时，可以用 <code>--net</code> 选项指定容器的网络模式，Docker 有以下 4 种网络模式：
</p>

<ul class="org-ul">
<li>host 模式，使用 &#x2013;net=host 指定</li>
<li>container 模式，使用 &#x2013;net=container:NAME_or_ID 指定</li>
<li>none 模式，使用 &#x2013;net=none 指定</li>
<li>bridge 模式，使用 &#x2013;net=bridge 指定，默认设置</li>
</ul>
</div>

<div id="outline-container-org2e9f13e" class="outline-4">
<h4 id="org2e9f13e"><span class="section-number-4">6.1.1</span> host 模式</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。
</p>

<p>
例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。
</p>
</div>
</div>

<div id="outline-container-org9ecc43d" class="outline-4">
<h4 id="org9ecc43d"><span class="section-number-4">6.1.2</span> container 模式</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。
</p>
</div>
</div>

<div id="outline-container-org826eb6c" class="outline-4">
<h4 id="org826eb6c"><span class="section-number-4">6.1.3</span> none模式</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。
</p>
</div>
</div>

<div id="outline-container-orgc56048c" class="outline-4">
<h4 id="orgc56048c"><span class="section-number-4">6.1.4</span> bridge模式</h4>
<div class="outline-text-4" id="text-6-1-4">

<div class="figure">
<p><img src="./images/vethbridge.png" alt="vethbridge.png" />
</p>
</div>

<p>
图：<a href="http://www.wickedawesometech.us/2014/07/the-container-world-part-2-networking.html">The Container World Part 2 Networking</a>
</p>

<p>
bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）
</p>
</div>
</div>
</div>

<div id="outline-container-org13430fd" class="outline-3">
<h3 id="org13430fd"><span class="section-number-3">6.2</span> 列出当前主机网桥</h3>
<div class="outline-text-3" id="text-6-2">
<pre class="example">
$ sudo brctl show  # brctl 工具依赖 bridge-utils 软件包
bridge name bridge id STP enabled interfaces
docker0 8000.000000000000 no
</pre>
</div>
</div>

<div id="outline-container-orgc3e0d67" class="outline-3">
<h3 id="orgc3e0d67"><span class="section-number-3">6.3</span> 查看当前 docker0 ip</h3>
<div class="outline-text-3" id="text-6-3">
<pre class="example">
$ sudo ifconfig docker0
docker0 Link encap:Ethernet HWaddr xx:xx:xx:xx:xx:xx
inet addr:172.17.42.1 Bcast:0.0.0.0 Mask:255.255.0.0
</pre>

<p>
在容器运行时，每个容器都会分配一个特定的虚拟机口并桥接到 docker0。每个容器都会配置同 docker0 ip 相同网段的专用 ip 地址，docker0 的 IP 地址被用于所有容器的默认网关。
</p>
</div>
</div>

<div id="outline-container-org4cb982a" class="outline-3">
<h3 id="org4cb982a"><span class="section-number-3">6.4</span> 运行一个容器</h3>
<div class="outline-text-3" id="text-6-4">
<pre class="example">
$ sudo docker run -t -i -d ubuntu /bin/bash
52f811c5d3d69edddefc75aff5a4525fc8ba8bcfa1818132f9dc7d4f7c7e78b4
$ sudo brctl show
bridge name bridge id STP enabled interfaces
docker0 8000.fef213db5a66 no vethQCDY1N
</pre>

<p>
以上, docker0 扮演着 52f811c5d3d6 container 这个容器的虚拟接口 vethQCDY1N interface 桥接的角色。
</p>
</div>

<div id="outline-container-orgf728a28" class="outline-4">
<h4 id="orgf728a28"><span class="section-number-4">6.4.1</span> 使用特定范围的 IP</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
Docker 会尝试寻找没有被主机使用的 ip 段，尽管它适用于大多数情况下，但是它不是万能的，有时候我们还是需要对 ip 进一步规划。Docker 允许你管理 docker0 桥接或者通过 <code>-b</code> 选项自定义桥接网卡，需要安装 <code>bridge-utils</code> 软件包。
</p>

<p>
基本步骤如下：
</p>

<ul class="org-ul">
<li>ensure Docker is stopped
<ul class="org-ul">
<li># 确保 docker 的进程是停止的</li>
</ul></li>
<li>create your own bridge (bridge0 for example)
<ul class="org-ul">
<li># 创建自定义网桥</li>
</ul></li>
<li>assign a specific IP to this bridge
<ul class="org-ul">
<li># 给网桥分配特定的 ip</li>
</ul></li>
<li>start Docker with the -b=bridge0 parameter
<ul class="org-ul">
<li># 以 -b 的方式指定网桥</li>
</ul></li>
</ul>

<pre class="example">
# Stopping Docker and removing docker0

$ sudo service docker stop
$ sudo ip link set dev docker0 down
$ sudo brctl delbr docker0

# Create our own bridge

$ sudo brctl addbr bridge0
$ sudo ip addr add 192.168.5.1/24 dev bridge0
$ sudo ip link set dev bridge0 up

# Confirming that our bridge is up and running

$ ip addr show bridge0
4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default
    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff
    inet 192.168.5.1/24 scope global bridge0
       valid_lft forever preferred_lft forever

# Tell Docker about it and restart (on Ubuntu)

$ echo 'DOCKER_OPTS="-b=bridge0"' &gt;&gt; /etc/default/docker
$ sudo service docker start
</pre>

<p>
参考文档: <a href="https://docs.docker.com/articles/networking/">Network Configuration</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org5e73d00" class="outline-3">
<h3 id="org5e73d00"><span class="section-number-3">6.5</span> 不同主机间容器通信</h3>
<div class="outline-text-3" id="text-6-5">
<p>
不同容器之间的通信可以借助于 pipework 这个工具：
</p>

<pre class="example">
$ git clone https://github.com/jpetazzo/pipework.git
$ sudo cp -rp pipework/pipework /usr/local/bin/
</pre>
</div>

<div id="outline-container-org2944faa" class="outline-4">
<h4 id="org2944faa"><span class="section-number-4">6.5.1</span> 安装相应依赖软件</h4>
<div class="outline-text-4" id="text-6-5-1">
<pre class="example">
$ sudo apt-get install iputils-arping bridge-utils -y
</pre>
</div>
</div>

<div id="outline-container-org3607e36" class="outline-4">
<h4 id="org3607e36"><span class="section-number-4">6.5.2</span> 桥接网络</h4>
<div class="outline-text-4" id="text-6-5-2">
<p>
桥接网络可以参考 <a href="https://github.com/opskumu/Day/blob/master/tips/tips.md">日常问题处理 Tips</a> 关于桥接的配置说明，这里不再赘述。
</p>

<pre class="example">
# brctl show
bridge name     bridge id               STP enabled     interfaces
br0             8000.000c291412cd       no              eth0
docker0         8000.56847afe9799       no              vetheb48029
</pre>

<p>
可以删除 docker0，直接把 docker 的桥接指定为 br0。也可以保留使用默认的配置，这样单主机容器之间的通信可以通过 docker0，而跨主机不同容器之间通过 pipework 新建 docker 容器的网卡桥接到 br0，这样跨主机容器之间就可以通信了。
</p>

<ul class="org-ul">
<li>ubuntu</li>
</ul>

<pre class="example">
$ sudo service docker stop
$ sudo ip link set dev docker0 down
$ sudo brctl delbr docker0
$ echo 'DOCKER_OPTS="-b=br0"' &gt;&gt; /etc/default/docker
$ sudo service docker start
</pre>

<ul class="org-ul">
<li>CentOS 7/RHEL 7</li>
</ul>

<pre class="example">
$ sudo systemctl stop docker
$ sudo ip link set dev docker0 down
$ sudo brctl delbr docker0
$ cat /etc/sysconfig/docker | grep 'OPTIONS='
OPTIONS=--selinux-enabled -b=br0 -H fd://
$ sudo systemctl start docker
</pre>
</div>
</div>

<div id="outline-container-org8933318" class="outline-4">
<h4 id="org8933318"><span class="section-number-4">6.5.3</span> pipework</h4>
<div class="outline-text-4" id="text-6-5-3">

<div class="figure">
<p><img src="./images/docker_bridge.png" alt="docker_bridge.png" />
</p>
</div>

<p>
不同容器之间的通信可以借助于 pipework 这个工具给 docker 容器新建虚拟网卡并绑定 IP 桥接到 br0
</p>

<pre class="example">
$ git clone https://github.com/jpetazzo/pipework.git
$ sudo cp -rp pipework/pipework /usr/local/bin/
$ pipework
Syntax:
pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; &lt;ipaddr&gt;/&lt;subnet&gt;[@default_gateway] [macaddr][@vlan]
pipework &lt;hostinterface&gt; [-i containerinterface] &lt;guest&gt; dhcp [macaddr][@vlan]
pipework --wait [-i containerinterface]
</pre>

<p>
如果删除了默认的 docker0 桥接，把 docker 默认桥接指定到了 br0，则最好在创建容器的时候加上 <code>--net=none</code> ，防止自动分配的 IP 在局域网中有冲突。
</p>

<pre class="example">
$ sudo docker run --rm -ti --net=none ubuntu:14.04 /bin/bash
root@a46657528059:/#
$                  # Ctrl-P + Ctrl-Q 回到宿主机 shell，容器 detach 状态
$ sudo docker  ps
CONTAINER ID    IMAGE          COMMAND       CREATED         STATUS          PORTS      NAMES
a46657528059    ubuntu:14.04   "/bin/bash"   4 minutes ago   Up 4 minutes               hungry_lalande
$ sudo pipework br0 -i eth0 a46657528059 192.168.115.10/24@192.168.115.2
# 默认不指定网卡设备名，则默认添加为 eth1
# 另外 pipework 不能添加静态路由，如果有需求则可以在 run 的时候加上 --privileged=true 权限在容器中手动添加，
# 但这种安全性有缺陷，可以通过 ip netns 操作
$ sudo docker attach a46657528059
root@a46657528059:/# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 86:b6:6b:e8:2e:4d
          inet addr:192.168.115.10  Bcast:0.0.0.0  Mask:255.255.255.0
          inet6 addr: fe80::84b6:6bff:fee8:2e4d/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:648 (648.0 B)  TX bytes:690 (690.0 B)

root@a46657528059:/# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.115.2   0.0.0.0         UG    0      0        0 eth0
192.168.115.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0
</pre>

<p>
使用 <code>ip netns</code> 添加静态路由，避免创建容器使用 <code>--privileged=true</code> 选项造成一些不必要的安全问题：
</p>

<pre class="example">
$ docker inspect --format="{% raw %}{{ .State.Pid }}{% endraw %}" a46657528059 # 获取指定容器 pid
6350
$ sudo ln -s /proc/6350/ns/net /var/run/netns/6350
$ sudo ip netns exec 6350 ip route add 192.168.0.0/16 dev eth0 via 192.168.115.2
$ sudo ip netns exec 6350 ip route    # 添加成功
192.168.0.0/16 via 192.168.115.2 dev eth0
... ...
</pre>

<p>
在其它宿主机进行相应的配置，新建容器并使用 pipework 添加虚拟网卡桥接到 br0，测试通信情况即可。
</p>

<p>
另外，pipework 可以创建容器的 vlan 网络，这里不作过多的介绍了，官方文档已经写的很清楚了，可以查看以下两篇文章：
</p>

<ul class="org-ul">
<li><a href="https://github.com/jpetazzo/pipework">Pipework 官方文档</a></li>
<li><a href="http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice">Docker 网络详解及 pipework 源码解读与实践</a></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgee4494c" class="outline-2">
<h2 id="orgee4494c"><span class="section-number-2">7</span> Dockerfile</h2>
<div class="outline-text-2" id="text-7">
<p>
Docker 可以通过 Dockerfile 的内容来自动构建镜像。Dockerfile 是一个包含创建镜像所有命令的文本文件，通过 <code>docker build</code> 命令可以根据 Dockerfile 的内容构建镜像，在介绍如何构建之前先介绍下 Dockerfile 的基本语法结构。
</p>

<p>
Dockerfile 有以下指令选项:
</p>

<ul class="org-ul">
<li><code>FROM</code></li>
<li><code>MAINTAINER</code></li>
<li><code>RUN</code></li>
<li><code>CMD</code></li>
<li><code>EXPOSE</code></li>
<li><code>ENV</code></li>
<li><code>ADD</code></li>
<li><code>COPY</code></li>
<li><code>ENTRYPOINT</code></li>
<li><code>VOLUME</code></li>
<li><code>USER</code></li>
<li><code>WORKDIR</code></li>
<li><code>ONBUILD</code></li>
</ul>
</div>

<div id="outline-container-orgd29a41f" class="outline-3">
<h3 id="orgd29a41f"><span class="section-number-3">7.1</span> FROM</h3>
<div class="outline-text-3" id="text-7-1">
<p>
用法:
</p>

<pre class="example">
FROM &lt;image&gt;
</pre>

<p>
或者
</p>

<pre class="example">
FROM &lt;image&gt;
</pre>

<ul class="org-ul">
<li><code>FROM</code> 指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来</li>
<li><code>FROM</code> 必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从 <code>FROM</code> 语句开始</li>
<li><code>FROM</code> 可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像</li>
<li>如果 <code>FROM</code> 语句没有指定镜像标签，则默认使用 <code>latest</code> 标签</li>
</ul>
</div>
</div>

<div id="outline-container-org805c39f" class="outline-3">
<h3 id="org805c39f"><span class="section-number-3">7.2</span> MAINTAINER</h3>
<div class="outline-text-3" id="text-7-2">
<p>
用法:
</p>

<pre class="example">
MAINTAINER &lt;name&gt;
</pre>

<p>
指定创建镜像的用户
</p>

<p>
RUN 有两种使用方式
</p>

<ul class="org-ul">
<li>RUN (the command is run in a shell - /bin/sh -c - shell form)</li>
<li>RUN ["executable", "param1", "param2"] (exec form)</li>
</ul>

<p>
每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的 <code>RUN</code> 都在之前 <code>RUN</code> 提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的版本控制。
</p>

<p>
exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如：
</p>

<pre class="example">
RUN [ "echo", "$HOME" ]
</pre>

<p>
这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的
</p>

<pre class="example">
RUN [ "sh", "-c", "echo", "$HOME" ]
</pre>

<p>
<code>RUN</code> 产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用 <code>--no-cache</code> 选项，即 <code>docker build --no-cache</code> ，如此便不会缓存。
</p>
</div>
</div>

<div id="outline-container-org67c8482" class="outline-3">
<h3 id="org67c8482"><span class="section-number-3">7.3</span> CMD</h3>
<div class="outline-text-3" id="text-7-3">
<p>
<code>CMD</code> 有三种使用方式:
</p>

<ul class="org-ul">
<li>CMD ["executable","param1","param2"] (exec form, this is the preferred form, 优先选择)</li>
<li>CMD ["param1","param2"] (as default parameters to <code>ENTRYPOINT</code>)</li>
<li>CMD command param1 param2 (shell form)</li>
</ul>

<p>
<code>CMD</code> 指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。
</p>

<p>
<code>CMD</code> 的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。
</p>

<blockquote>
<p>
<code>CMD</code> 会在启动容器的时候执行，build 时不执行，而 <code>RUN</code> 只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与 <code>RUN</code> 无关了，这个初学者容易弄混这个概念，这里简单注解一下。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgfeae381" class="outline-3">
<h3 id="orgfeae381"><span class="section-number-3">7.4</span> EXPOSE</h3>
<div class="outline-text-3" id="text-7-4">
<pre class="example">
EXPOSE &lt;port&gt; [&lt;port&gt;...]
</pre>

<p>
告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用 <code>-p</code> 或者 <code>-P</code> 选项生效。
</p>
</div>
</div>

<div id="outline-container-orga046680" class="outline-3">
<h3 id="orga046680"><span class="section-number-3">7.5</span> ENV</h3>
<div class="outline-text-3" id="text-7-5">
<pre class="example">
ENV &lt;key&gt; &lt;value&gt;       # 只能设置一个变量
ENV &lt;key&gt;=&lt;value&gt; ...   # 允许一次设置多个变量
</pre>

<p>
指定一个环节变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保留。
</p>

<p>
例子:
</p>

<pre class="example">
ENV myName="John Doe" myDog=Rex\ The\ Dog \
    myCat=fluffy
</pre>

<p>
等同于
</p>

<pre class="example">
ENV myName John Doe
ENV myDog Rex The Dog
ENV myCat fluffy
</pre>
</div>
</div>

<div id="outline-container-org83c10e3" class="outline-3">
<h3 id="org83c10e3"><span class="section-number-3">7.6</span> ADD</h3>
<div class="outline-text-3" id="text-7-6">
<pre class="example">
ADD &lt;src&gt;... &lt;dest&gt;
</pre>

<p>
<code>ADD</code> 复制本地主机文件、目录或者远程文件 URLS 从 &lt;src&gt; 并且添加到容器指定路径中 &lt;dest&gt;。
</p>

<p>
&lt;src&gt; 支持通过 GO 的正则模糊匹配，具体规则可参见 <a href="http://golang.org/pkg/path/filepath/#Match">Go filepath.Match</a>
</p>

<pre class="example">
ADD hom* /mydir/        # adds all files starting with "hom"
ADD hom?.txt /mydir/    # ? is replaced with any single character
</pre>

<ul class="org-ul">
<li>&lt;dest&gt; 路径必须是绝对路径，如果 &lt;dest&gt; 不存在，会自动创建对应目录</li>
<li>&lt;src&gt; 路径必须是 Dockerfile 所在路径的相对路径</li>
<li>&lt;src&gt; 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制</li>
</ul>
</div>
</div>

<div id="outline-container-orgfb0ad1d" class="outline-3">
<h3 id="orgfb0ad1d"><span class="section-number-3">7.7</span> COPY</h3>
<div class="outline-text-3" id="text-7-7">
<pre class="example">
COPY &lt;src&gt;... &lt;dest&gt;
</pre>

<p>
<code>COPY</code> 复制新文件或者目录从 &lt;src&gt; 添加到容器指定路径中 &lt;dest&gt;。用法同 <code>ADD</code> ，唯一的不同是不能指定远程文件 URLS。
</p>
</div>
</div>

<div id="outline-container-org83f6e48" class="outline-3">
<h3 id="org83f6e48"><span class="section-number-3">7.8</span> ENTRYPOINT</h3>
<div class="outline-text-3" id="text-7-8">
<ul class="org-ul">
<li>ENTRYPOINT ["executable", "param1", "param2"] (the preferred exec form，优先选择)</li>
<li>ENTRYPOINT command param1 param2 (shell form)</li>
</ul>

<p>
配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而 <code>CMD</code> 是可以被覆盖的。如果需要覆盖，则可以使用 <code>docker run --entrypoint</code> 选项。
</p>

<p>
每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code> ，当指定多个时，只有最后一个生效。
</p>
</div>

<div id="outline-container-orgd26c057" class="outline-4">
<h4 id="orgd26c057"><span class="section-number-4">7.8.1</span> Exec form ENTRYPOINT 例子</h4>
<div class="outline-text-4" id="text-7-8-1">
<p>
通过 <code>ENTRYPOINT</code> 使用 exec form 方式设置稳定的默认命令和选项，而使用 <code>CMD</code> 添加默认之外经常被改动的选项。
</p>

<pre class="example">
FROM ubuntu
ENTRYPOINT ["top", "-b"]
CMD ["-c"]
</pre>

<p>
通过 Dockerfile 使用 <code>ENTRYPOINT</code> 展示前台运行 Apache 服务
</p>

<pre class="example">
FROM debian:stable
RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2
EXPOSE 80 443
VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"]
ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
</pre>
</div>
</div>

<div id="outline-container-org43d035c" class="outline-4">
<h4 id="org43d035c"><span class="section-number-4">7.8.2</span> Shell form ENTRYPOINT 例子</h4>
<div class="outline-text-4" id="text-7-8-2">
<p>
这种方式会在 <code>/bin/sh -c</code> 中执行，会忽略任何 <code>CMD</code> 或者 <code>docker run</code> 命令行选项，为了确保 <code>docker stop</code> 能够停止长时间运行 <code>ENTRYPOINT</code> 的容器，确保执行的时候使用 <code>exec</code> 选项。
</p>

<pre class="example">
FROM ubuntu
ENTRYPOINT exec top -b
</pre>

<p>
如果在 <code>ENTRYPOINT</code> 忘记使用 <code>exec</code> 选项，则可以使用 <code>CMD</code> 补上:
</p>

<pre class="example">
FROM ubuntu
ENTRYPOINT top -b
CMD --ignored-param1 # --ignored-param2 ... --ignored-param3 ... 依此类推
</pre>
</div>
</div>
</div>

<div id="outline-container-orga69ada7" class="outline-3">
<h3 id="orga69ada7"><span class="section-number-3">7.9</span> VOLUME</h3>
<div class="outline-text-3" id="text-7-9">
<pre class="example">
VOLUME ["/data"]
</pre>

<p>
创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。
</p>
</div>
</div>

<div id="outline-container-org531c72a" class="outline-3">
<h3 id="org531c72a"><span class="section-number-3">7.10</span> USER</h3>
<div class="outline-text-3" id="text-7-10">
<pre class="example">
USER daemon
</pre>

<p>
指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 、 <code>CMD</code> 、 <code>ENTRYPOINT</code> 也会使用指定用户。
</p>
</div>
</div>

<div id="outline-container-org2772376" class="outline-3">
<h3 id="org2772376"><span class="section-number-3">7.11</span> WORKDIR</h3>
<div class="outline-text-3" id="text-7-11">
<pre class="example">
WORKDIR /path/to/workdir
</pre>

<p>
为后续的 <code>RUN</code> 、 <code>CMD</code> 、 <code>ENTRYPOINT</code> 指令配置工作目录。可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。
</p>

<pre class="example">
WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
</pre>

<p>
最终路径是 <code>/a/b/c</code>
</p>

<p>
<code>WORKDIR</code> 指令可以在 <code>ENV</code> 设置变量之后调用环境变量:
</p>

<pre class="example">
ENV DIRPATH /path
WORKDIR $DIRPATH/$DIRNAME
</pre>

<p>
最终路径则为 /path/$DIRNAME。
</p>
</div>
</div>

<div id="outline-container-org6b52598" class="outline-3">
<h3 id="org6b52598"><span class="section-number-3">7.12</span> ONBUILD</h3>
<div class="outline-text-3" id="text-7-12">
<pre class="example">
ONBUILD [INSTRUCTION]
</pre>

<p>
配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。
</p>

<p>
例如，Dockerfile 使用如下的内容创建了镜像 image-A：
</p>

<pre class="example">
[...]
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
[...]
</pre>

<p>
如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。
</p>

<pre class="example">
# Automatically run the following
ADD . /app/src
RUN /usr/local/bin/python-build --dir /app/src
</pre>

<p>
使用 <code>ONBUILD</code> 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。
</p>
</div>
</div>

<div id="outline-container-org9bb66f7" class="outline-3">
<h3 id="org9bb66f7"><span class="section-number-3">7.13</span> Dockerfile Examples</h3>
<div class="outline-text-3" id="text-7-13">
<pre class="example">
# Nginx
#
# VERSION               0.0.1

FROM      ubuntu
MAINTAINER Victor Vieux &lt;victor@docker.com&gt;

RUN apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server

# Firefox over VNC
#
# VERSION               0.3

FROM ubuntu

# Install vnc, xvfb in order to create a 'fake' display and firefox
RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox
RUN mkdir ~/.vnc
# Setup a password
RUN x11vnc -storepasswd 1234 ~/.vnc/passwd
# Autostart firefox (might not be the best way, but it does the trick)
RUN bash -c 'echo "firefox" &gt;&gt; /.bashrc'

EXPOSE 5900
CMD    ["x11vnc", "-forever", "-usepw", "-create"]

# Multiple images example
#
# VERSION               0.1

FROM ubuntu
RUN echo foo &gt; bar
# Will output something like ===&gt; 907ad6c2736f

FROM ubuntu
RUN echo moo &gt; oink
# Will output something like ===&gt; 695d7793cbe4

# You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with
# /oink.
</pre>
</div>
</div>

<div id="outline-container-org706144e" class="outline-3">
<h3 id="org706144e"><span class="section-number-3">7.14</span> docker build</h3>
<div class="outline-text-3" id="text-7-14">
<pre class="example">
$ docker build --help

Usage: docker build [OPTIONS] PATH | URL | -

Build a new image from the source code at PATH

  --force-rm=false     Always remove intermediate containers, even after unsuccessful builds # 移除过渡容器，即使构建失败
  --no-cache=false     Do not use cache when building the image                              # 不实用 cache
  -q, --quiet=false    Suppress the verbose output generated by the containers
  --rm=true            Remove intermediate containers after a successful build               # 构建成功后移除过渡层容器
  -t, --tag=""         Repository name (and optionally a tag) to be applied to the resulting image in case of success
</pre>

<p>
参考文档：<a href="https://docs.docker.com/reference/builder/">Dockerfile Reference</a>
</p>
</div>
</div>

<div id="outline-container-org081ecf9" class="outline-3">
<h3 id="org081ecf9"><span class="section-number-3">7.15</span> dockerfile 最佳实践</h3>
<div class="outline-text-3" id="text-7-15">
<ul class="org-ul">
<li>使用 <code>.dockerignore</code> 文件</li>
</ul>

<p>
为了在 <code>docker build</code> 过程中更快上传和更加高效，应该使用一个 <code>.dockerignore</code> 文件用来排除构建镜像时不需要的文件或目录。例如,除非 <code>.git</code> 在构建过程中需要用到，否则你应该将它添加到 <code>.dockerignore</code> 文件中，这样可以节省很多时间。
</p>

<ul class="org-ul">
<li>避免安装不必要的软件包</li>
</ul>

<p>
为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个数据库镜像中安装一个文本编辑器。
</p>

<ul class="org-ul">
<li>每个容器都跑一个进程</li>
</ul>

<p>
在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 <a href="https://docs.docker.com/userguide/dockerlinks/">Linking Containers Together</a>。
</p>

<ul class="org-ul">
<li>最小化层</li>
</ul>

<p>
我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于 <code>Dockerfile</code> ，应该找到可读性和最小化层之间的平衡。
</p>

<ul class="org-ul">
<li>多行参数排序</li>
</ul>

<p>
如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用 <code>\</code> 换行:
</p>

<pre class="example">
RUN apt-get update &amp;&amp; apt-get install -y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion
</pre>

<ul class="org-ul">
<li>创建缓存</li>
</ul>

<p>
镜像构建过程中会按照 <code>Dockerfile</code> 的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在 <code>docker build</code> 时添加 <code>--no-cache=true</code> 选项。
</p>

<p>
从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比 <code>Dockerfile</code> 指令和子镜像就足够了。 <code>ADD</code> 和 <code>COPY</code> 指令除外，执行 <code>ADD</code> 和 <code>COPY</code> 时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。 <code>RUN apt-get -y update</code> 命令只检查命令是否匹配，如果匹配就不会再执行更新了。
</p>

<blockquote>
<p>
为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。
</p>
</blockquote>
</div>

<div id="outline-container-org037ee8c" class="outline-4">
<h4 id="org037ee8c"><span class="section-number-4">7.15.1</span> Dockerfile 指令</h4>
<div class="outline-text-4" id="text-7-15-1">
<ul class="org-ul">
<li><code>FROM</code>: 只要可能就使用官方镜像库作为基础镜像</li>
<li><code>RUN</code>: 为保持可读性、方便理解、可维护性，把长或者复杂的 <code>RUN</code> 语句使用 <code>\</code> 分隔符分成多行
<ul class="org-ul">
<li>不建议 <code>RUN apt-get update</code> 独立成行，否则如果后续包有更新，那么也不会再执行更新</li>
<li>避免使用 <code>RUN apt-get upgrade</code> 或者 <code>dist-upgrade</code> ，很多必要的包在一个非 <code>privileged</code> 权限的容器里是无法升级的。如果知道某个包更新，使用 <code>apt-get install -y xxx</code></li>
<li>标准写法
<ul class="org-ul">
<li><code>RUN apt-get update &amp;&amp; apt-get install -y package-bar package-foo</code></li>
</ul></li>
</ul></li>
</ul>

<p>
例子:
</p>

<pre class="example">
RUN apt-get update &amp;&amp; apt-get install -y \
    aufs-tools \
    automake \
    btrfs-tools \
    build-essential \
    curl \
    dpkg-sig \
    git \
    iptables \
    libapparmor-dev \
    libcap-dev \
    libsqlite3-dev \
    lxc=1.0* \
    mercurial \
    parallel \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.0*
</pre>

<ul class="org-ul">
<li><code>CMD</code>: 推荐使用 <code>CMD [“executable”, “param1”, “param2”…]</code> 这种格式， <code>CMD [“param”, “param”]</code> 则配合 <code>ENTRYPOINT</code> 使用</li>
<li><code>EXPOSE</code>: Dockerfile 指定要公开的端口，使用 <code>docker run</code> 时指定映射到宿主机的端口即可</li>
<li><code>ENV</code>: 为了使新的软件更容易运行，可以使用 <code>ENV</code> 更新 <code>PATH</code> 变量。如 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 确保 <code>CMD ["nginx"]</code> 即可运行</li>
</ul>

<p>
<code>ENV</code> 也可以这样定义变量：
</p>

<pre class="example">
ENV PG_MAJOR 9.3
ENV PG_VERSION 9.3.4
RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …
ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH
</pre>

<ul class="org-ul">
<li><code>ADD</code> or <code>COPY</code>: <code>ADD</code> 比 <code>COPY</code> 多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL</li>
</ul>

<p>
如不推荐这种方式:
</p>

<pre class="example">
ADD http://example.com/big.tar.xz /usr/src/things/
RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
RUN make -C /usr/src/things all
</pre>

<p>
推荐使用 curl 或者 wget 替换，使用如下方式:
</p>

<pre class="example">
RUN mkdir -p /usr/src/things \
    &amp;&amp; curl -SL http://example.com/big.tar.gz \
    | tar -xJC /usr/src/things \
    &amp;&amp; make -C /usr/src/things all
</pre>

<p>
如果不需要添加 tar 文件，推荐使用 <code>COPY</code> 。
</p>

<p>
参考文档:
</p>

<ul class="org-ul">
<li><a href="https://docs.docker.com/articles/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li>
<li><a href="http://dockerone.com/article/131">Dockerfile最佳实践（一）</a></li>
<li><a href="http://dockerone.com/article/132">Dockerfile最佳实践（二）</a></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org3c300b8" class="outline-2">
<h2 id="org3c300b8"><span class="section-number-2">8</span> 容器数据管理</h2>
<div class="outline-text-2" id="text-8">
<p>
docker管理数据的方式有两种：
</p>

<ul class="org-ul">
<li>数据卷</li>
<li>数据卷容器</li>
</ul>
</div>

<div id="outline-container-orgf9281c5" class="outline-3">
<h3 id="orgf9281c5"><span class="section-number-3">8.1</span> 数据卷</h3>
<div class="outline-text-3" id="text-8-1">
<p>
数据卷是一个或多个容器专门指定绕过 <code>Union File System</code> 的目录，为持续性或共享数据提供一些有用的功能：
</p>

<ul class="org-ul">
<li>数据卷可以在容器间共享和重用</li>
<li>数据卷数据改变是直接修改的</li>
<li>数据卷数据改变不会被包括在容器中</li>
<li>数据卷是持续性的，直到没有容器使用它们</li>
</ul>
</div>

<div id="outline-container-orgd85495e" class="outline-4">
<h4 id="orgd85495e"><span class="section-number-4">8.1.1</span> 添加一个数据卷</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
你可以使用 <code>-v</code> 选项添加一个数据卷，或者可以使用多次 <code>-v</code> 选项为一个 docker 容器运行挂载多个数据卷。
</p>

<pre class="example">
$ sudo docker run --name data -v /data -t -i ubuntu:14.04 /bin/bash
# 创建数据卷绑定到到新建容器，新建容器中会创建 /data 数据卷
bash-4.1# ls -ld /data/
drwxr-xr-x 2 root root 4096 Jul 23 06:59 /data/
bash-4.1# df -Th
Filesystem    Type    Size  Used Avail Use% Mounted on
... ...
              ext4     91G  4.6G   82G   6% /data
</pre>

<p>
创建的数据卷可以通过 <code>docker inspect</code> 获取宿主机对应路径
</p>

<pre class="example">
$ sudo docker inspect data
... ...
    "Volumes": {
        "/data": "/var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9"
    }, # 可以看到创建的数据卷宿主机路径
... ...
</pre>

<p>
或者直接指定获取
</p>

<pre class="example">
$ sudo docker inspect --format="{% raw %}{{ .Volumes }}{% endraw %}" data
map[/data: /var/lib/docker/vfs/dir/151de401d268226f96d824fdf444e77a4500aed74c495de5980c807a2ffb7ea9]
</pre>
</div>
</div>

<div id="outline-container-orge0722ca" class="outline-4">
<h4 id="orge0722ca"><span class="section-number-4">8.1.2</span> 挂载宿主机目录为一个数据卷</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
<code>-v</code> 选项除了可以创建卷，也可以挂载当前主机的一个目录到容器中。
</p>

<pre class="example">
$ sudo docker run --name web -v /source/:/web -t -i ubuntu:14.04 /bin/bash
bash-4.1# ls -ld /web/
drwxr-xr-x 2 root root 4096 Jul 23 06:59 /web/
bash-4.1# df -Th
... ...
              ext4     91G  4.6G   82G   6% /web
bash-4.1# exit
</pre>

<p>
默认挂载卷是可读写的，可以在挂载时指定只读
</p>

<pre class="example">
$ sudo docker run --rm --name test -v /source/:/test:ro -t -i ubuntu:14.04 /bin/bash
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd98ca35" class="outline-3">
<h3 id="orgd98ca35"><span class="section-number-3">8.2</span> 创建和挂载一个数据卷容器</h3>
<div class="outline-text-3" id="text-8-2">
<p>
如果你有一些持久性的数据并且想在容器间共享，或者想用在非持久性的容器上，最好的方法是创建一个数据卷容器，然后从此容器上挂载数据。
</p>

<p>
创建数据卷容器
</p>

<pre class="example">
$ sudo docker run -t -i -d -v /test --name test ubuntu:14.04 echo hello
</pre>

<p>
使用 <code>--volumes-from</code> 选项在另一个容器中挂载 /test 卷。不管 test 容器是否运行，其它容器都可以挂载该容器数据卷，当然如果只是单独的数据卷是没必要运行容器的。
</p>

<pre class="example">
$ sudo docker run -t -i -d --volumes-from test --name test1 ubuntu:14.04 /bin/bash
</pre>

<p>
添加另一个容器
</p>

<pre class="example">
$ sudo docker run -t -i -d --volumes-from test --name test2 ubuntu:14.04 /bin/bash
</pre>

<p>
也可以继承其它挂载有 /test 卷的容器
</p>

<pre class="example">
$ sudo docker run -t -i -d --volumes-from test1 --name test3 ubuntu:14.04 /bin/bash
</pre>


<div class="figure">
<p><img src="./images/docker_data.png" alt="docker_data.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org2e9f1a3" class="outline-3">
<h3 id="org2e9f1a3"><span class="section-number-3">8.3</span> 备份、恢复或迁移数据卷</h3>
<div class="outline-text-3" id="text-8-3">
</div>
<div id="outline-container-org31ebf9b" class="outline-4">
<h4 id="org31ebf9b"><span class="section-number-4">8.3.1</span> 备份</h4>
<div class="outline-text-4" id="text-8-3-1">
<pre class="example">
$ sudo docker run --rm --volumes-from test -v $(pwd):/backup ubuntu:14.04 tar cvf /backup/test.tar /test
tar: Removing leading `/' from member names
/test/
/test/b
/test/d
/test/c
/test/a
</pre>

<p>
启动一个新的容器并且从 <code>test</code> 容器中挂载卷，然后挂载当前目录到容器中为 backup，并备份 test 卷中所有的数据为 test.tar，执行完成之后删除容器 <code>--rm</code> ，此时备份就在当前的目录下，名为 <code>test.tar</code> 。
</p>

<pre class="example">
$ ls        # 宿主机当前目录下产生了 test 卷的备份文件 test.tar
test.tar
</pre>
</div>
</div>

<div id="outline-container-orgad688cb" class="outline-4">
<h4 id="orgad688cb"><span class="section-number-4">8.3.2</span> 恢复</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
你可以恢复给同一个容器或者另外的容器，新建容器并解压备份文件到新的容器数据卷
</p>

<pre class="example">
$ sudo docker run -t -i -d -v /test --name test4 ubuntu:14.04  /bin/bash
$ sudo docker run --rm --volumes-from test4 -v $(pwd):/backup ubuntu:14.04 tar xvf /backup/test.tar -C /
# 恢复之前的文件到新建卷中，执行完后自动删除容器
test/
test/b
test/d
test/c
test/a
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b8ab81" class="outline-3">
<h3 id="org1b8ab81"><span class="section-number-3">8.4</span> 删除 Volumes</h3>
<div class="outline-text-3" id="text-8-4">
<p>
Volume 只有在下列情况下才能被删除：
</p>

<ul class="org-ul">
<li><code>docker rm -v</code> 删除容器时添加了 <code>-v</code> 选项</li>
<li><code>docker run --rm</code> 运行容器时添加了 <code>--rm</code> 选项</li>
</ul>

<p>
否则，会在 <code>/var/lib/docker/vfs/dir</code> 目录中遗留很多不明目录。
</p>

<p>
参考文档：
</p>

<ul class="org-ul">
<li><a href="http://docs.docker.com/userguide/dockervolumes/#data-volumes">Managing Data in Containers</a></li>
<li><a href="http://dockerone.com/article/128">深入理解Docker Volume（一）</a></li>
<li><a href="http://dockerone.com/article/129">深入理解Docker Volume（二）</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0c3fe77" class="outline-2">
<h2 id="org0c3fe77"><span class="section-number-2">9</span> 链接容器</h2>
<div class="outline-text-2" id="text-9">
<p>
docker 允许把多个容器连接在一起，相互交互信息。docker 链接会创建一种容器父子级别的关系，其中父容器可以看到其子容器提供的信息。
</p>
</div>

<div id="outline-container-org1fa99a3" class="outline-3">
<h3 id="org1fa99a3"><span class="section-number-3">9.1</span> 容器命名</h3>
<div class="outline-text-3" id="text-9-1">
<p>
在创建容器时，如果不指定容器的名字，则默认会自动创建一个名字，这里推荐给容器命名：
</p>

<ul class="org-ul">
<li>给容器命名方便记忆，如命名运行 web 应用的容器为 web</li>
<li>为 docker 容器提供一个参考，允许方便其他容器调用，如把容器 web 链接到容器 db</li>
</ul>

<p>
可以通过 <code>--name</code> 选项给容器自定义命名：
</p>

<pre class="example">
$ sudo docker run -d -t -i --name test ubuntu:14.04 bash
$ sudo docker  inspect --format="{% raw %}{{ .Nmae }}{% endraw %}" test
/test
</pre>

<blockquote>
<p>
注：容器名称必须唯一，即你只能命名一个叫 <code>test</code> 的容器。如果你想复用容器名，则必须在创建新的容器前通过 <code>docker rm</code> 删除旧的容器或者创建容器时添加 <code>--rm</code> 选项。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgb2afa10" class="outline-3">
<h3 id="orgb2afa10"><span class="section-number-3">9.2</span> 链接容器</h3>
<div class="outline-text-3" id="text-9-2">
<p>
链接允许容器间安全通信，使用 <code>--link</code> 选项创建链接。
</p>

<pre class="example">
$ sudo docker run -d --name db training/postgres
</pre>

<p>
基于 training/postgres 镜像创建一个名为 db 的容器，然后下面创建一个叫做 web 的容器，并且将它与 db 相互连接在一起
</p>

<pre class="example">
$ sudo docker run -d -P --name web --link db:db training/webapp python app.py
</pre>

<p>
<code>--link &lt;name or id&gt;:alias</code> 选项指定链接到的容器。
</p>

<p>
查看 web 容器的链接关系:
</p>

<pre class="example">
$ sudo docker inspect -f "{% raw %}{{ .HostConfig.Links }}{% endraw %}" web
[/db:/web/db]
</pre>

<p>
可以看到 web 容器被链接到 db 容器为 =/web/db=，这允许 web 容器访问 db 容器的信息。
</p>

<p>
容器之间的链接实际做了什么？一个链接允许一个源容器提供信息访问给一个接收容器。在本例中，web 容器作为一个接收者，允许访问源容器 db 的相关服务信息。Docker 创建了一个安全隧道而不需要对外公开任何端口给外部容器，因此不需要在创建容器的时候添加 <code>-p</code> 或 <code>-P</code> 指定对外公开的端口，这也是链接容器的最大好处，本例为 PostgreSQL 数据库。
</p>

<p>
Docker 主要通过以下两个方式提供连接信息给接收容器：
</p>

<ul class="org-ul">
<li>环境变量</li>
<li>更新 <code>/etc/hosts</code> 文件</li>
</ul>
</div>

<div id="outline-container-org01ed06d" class="outline-4">
<h4 id="org01ed06d"><span class="section-number-4">9.2.1</span> 环境变量</h4>
<div class="outline-text-4" id="text-9-2-1">
<p>
当两个容器链接，Docker 会在目标容器上设置一些环境变量，以获取源容器的相关信息。
</p>

<p>
首先，Docker 会在每个通过 <code>--link</code> 选项指定别名的目标容器上设置一个 <code>&lt;alias&gt;_NAME</code> 环境变量。如果一个名为 web 的容器通过 <code>--link db:webdb</code> 被链接到一个名为 db 的数据库容器，那么 web 容器上会设置一个环境变量为 <code>WEBDB_NAME=/web/webdb</code>
</p>

<p>
以之前的为例，Docker 还会设置端口变量:
</p>

<pre class="example">
$ sudo docker run --rm --name web2 --link db:db training/webapp env
. . .
DB_NAME=/web2/db
DB_PORT=tcp://172.17.0.5:5432
DB_PORT_5432_TCP=tcp://172.17.0.5:5432  # &lt;name&gt;_PORT_&lt;port&gt;_&lt;protocol&gt; 协议可以是 TCP 或 UDP
DB_PORT_5432_TCP_PROTO=tcp
DB_PORT_5432_TCP_PORT=5432
DB_PORT_5432_TCP_ADDR=172.17.0.5
. . .
</pre>

<blockquote>
<p>
注：这些环境变量只设置给容器中的第一个进程，类似一些守护进程 (如 sshd ) 当他们派生 shells 时会清除这些变量
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org7603c1e" class="outline-4">
<h4 id="org7603c1e"><span class="section-number-4">9.2.2</span> 更新 <code>/etc/hosts</code> 文件</h4>
<div class="outline-text-4" id="text-9-2-2">
<p>
除了环境变量，Docker 会在目标容器上添加相关主机条目到 <code>/etc/hosts</code> 中，上例中就是 web 容器。
</p>

<pre class="example">
$ sudo docker run -t -i --rm --link db:db training/webapp /bin/bash
root@aed84ee21bde:/opt/webapp# cat /etc/hosts
172.17.0.7  aed84ee21bde
. . .
172.17.0.5  db
</pre>

<blockquote>
<p>
<code>/etc/host</code> 文件在源容器被重启之后会自动更新 IP 地址，而环境变量中的 IP 地址则不会自动更新的。
</p>
</blockquote>
</div>
</div>
</div>
</div>

<div id="outline-container-org7ffd7fe" class="outline-2">
<h2 id="org7ffd7fe"><span class="section-number-2">10</span> 构建私有库</h2>
<div class="outline-text-2" id="text-10">
<p>
Docker 官方提供了 docker registry 的构建方法 <a href="https://github.com/docker/docker-registry">docker-registry</a>
</p>
</div>

<div id="outline-container-org032b36d" class="outline-3">
<h3 id="org032b36d"><span class="section-number-3">10.1</span> 快速构建</h3>
<div class="outline-text-3" id="text-10-1">
<p>
快速构建 docker registry 通过以下两步:
</p>

<ul class="org-ul">
<li>安装 docker</li>
<li>运行 registry: <code>docker run -p 5000:5000 registry</code></li>
</ul>

<p>
这种方法通过 Docker hub 使用官方镜像 <a href="https://registry.hub.docker.com/_/registry/">official image from the Docker hub</a>
</p>
</div>
</div>

<div id="outline-container-orgba8a8d0" class="outline-3">
<h3 id="orgba8a8d0"><span class="section-number-3">10.2</span> 不使用容器构建 registry</h3>
<div class="outline-text-3" id="text-10-2">
</div>
<div id="outline-container-orgee1e5d0" class="outline-4">
<h4 id="orgee1e5d0"><span class="section-number-4">10.2.1</span> 安装必要的软件</h4>
<div class="outline-text-4" id="text-10-2-1">
<pre class="example">
$ sudo apt-get install build-essential python-dev libevent-dev python-pip liblzma-dev
</pre>
</div>
</div>

<div id="outline-container-org5f06dad" class="outline-4">
<h4 id="org5f06dad"><span class="section-number-4">10.2.2</span> 配置 docker-registry</h4>
<div class="outline-text-4" id="text-10-2-2">
<pre class="example">
sudo pip install docker-registry
</pre>

<p>
或者使用 github clone 手动安装
</p>

<pre class="example">
$ git clone https://github.com/dotcloud/docker-registry.git
$ cd docker-registry/
$ cp config/config_sample.yml config/config.yml
$ mkdir /data/registry -p
$ pip install .
</pre>
</div>
</div>

<div id="outline-container-org13bf186" class="outline-4">
<h4 id="org13bf186"><span class="section-number-4">10.2.3</span> 运行</h4>
<div class="outline-text-4" id="text-10-2-3">
<pre class="example">
docker-registry
</pre>
</div>
</div>

<div id="outline-container-orgdf29639" class="outline-4">
<h4 id="orgdf29639"><span class="section-number-4">10.2.4</span> 高级启动方式 「不推荐」</h4>
<div class="outline-text-4" id="text-10-2-4">
<p>
使用 <code>gunicorn</code> 控制:
</p>

<pre class="example">
gunicorn -c contrib/gunicorn_config.py docker_registry.wsgi:application
</pre>

<p>
或者对外监听开放
</p>

<pre class="example">
gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application
</pre>
</div>
</div>
</div>

<div id="outline-container-org08ca606" class="outline-3">
<h3 id="org08ca606"><span class="section-number-3">10.3</span> 提交指定容器到私有库</h3>
<div class="outline-text-3" id="text-10-3">
<pre class="example">
$ docker tag ubuntu:12.04 私有库IP:5000/ubuntu:12.04
$ docker push 私有库IP:5000/ubuntu
</pre>

<p>
更多的配置选项推荐阅读官方文档:
</p>

<ul class="org-ul">
<li><a href="https://github.com/docker/docker-registry/blob/master/README.md">Docker-Registry README</a></li>
<li><a href="https://github.com/docker/docker-registry/blob/master/ADVANCED.md">Docker-Registry advanced use</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2014-12-22 Mon 00:00</p>
<p class="author">Author: Kumu</p>
<p class="date">Created: 2019-09-23 Mon 20:00</p>
<p class="validation"></p>
</div>
</body>
</html>
